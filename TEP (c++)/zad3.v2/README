ROZWIĄZANE PROBLEMY

PRZY ZALOZENIU ZE ARGLIST MOZE BYC NULL PROBUJE ODCZYTAC JEJ PRYWATNE POLE
    int argCount() const{
        return argList->getElemCount();
    }
    bool isArgListNULL() {
        return argCount() == 0;
    }

CIEKAWSZY PRZYPADEK
PRZY KOPIOWANIU NODE POLE KOPII 'ARGLIST' DOMYSLNIE USTAWIALO SIE NA
COS W RODZAJU DOMYSLNEJ WARTOSCI I "ADDARG" RZUCAL SIGSEGV PONIEWAZ
LISTA ANI NIE BYLA NULL I PRZECHODZILA PRZEZ IF(ARGLIST==NULL)
ANI NIE MOGLA SIE POPRAWNIE DODAC BO NIE BYLA ZINICJALIZOWANA

Z TEGO
    Node(const Node &other) {
        value = other.getValue()+ "_copy";
        cout<<value<<endl;

        if(other.getArgList() != NULL)
            for (int i = 0; i < other.argCount(); i++)
                this->addArg(*new Node(*other.getArgList()->get(i)));
        else argList = NULL;
    }
DO TEGO
    Node(const Node &other) {
        value = other.getValue()+ "_copy";
        cout<<value<<endl;
        argList = NULL;
        if(other.getArgList() != NULL)
            for (int i = 0; i < other.argCount(); i++)
                this->addArg(*new Node(*other.getArgList()->get(i)));
    }

KOLEJNY ROZWIĄZANY PROBLEM
PRZY "COMP" DRZEW WYSTĘPOWAŁ PROBLEM Z ODCZYTYWANIEM ARRAYLISTY DRZEWA,
OKAZAŁO SIĘ ŻE PROBLEM WYSTĘPUJE TYLKO PRZY WCZESNIEJSZYM "JOIN", WYNIKAŁO TO Z PRZEOCZENIA
PRZYPADKU W KTÓRYM NIE ZINICJALIZUJEMY LISTY

BYLO TAK
    Tree &Tree::operator=(const Tree &other) {
        if (this != &other){
            delete varList;
            delete treeRoot;
            varList = NULL;
            treeRoot = NULL;
            if (!other.isVarListNULLorEmpty())
                varList = new ArrayList<string>(other.getVarListConst());
            if (other.getRoot() != NULL)
                treeRoot = new Node(*other.getRoot());
        }else
            return *this;
    }
JEST TAK
    Tree &Tree::operator=(const Tree &other) {
        if (this != &other){
            delete varList;
            delete treeRoot;
            varList = NULL;
            treeRoot = NULL;

            varList = new ArrayList<string>(other.getVarListConst());
            if (other.getRoot() != NULL)
                treeRoot = new Node(*other.getRoot());
        }else
            return *this;
    }
    CO ZADZIALALO XD

    "C:\Users\Hyperbook\Documents\GitHub\SEM3_IST\TEP (c++)\zad3.v2\cmake-build-debug\zad3_v2.exe"
    Wybierz
    1 - int,
    2 - double lub
    3 - string,
     cokolwiek innego - wyjscie: 3
    Podaj komende
    /; 'alalalamakota'; 'ala';
    nie ma zaladowanego drzewa
    Podaj komende
    enter /; 'alalalamakota'; 'ala';
    ZNALEZIONO BLAD WE WPROWADZONYM WYRAZENIU
    UCIETO WYRAZENIE - ZA DUZO ARGUMENTOW
    Podaj komende
    print
    'ala';
    Podaj komende
    enter / 'alalalamakota' 'ala'
    Podaj komende
    print
    /; 'alalalamakota'; 'ala';
    Podaj komende
    comp
    Wyliczono: amakota moj panie!
    Podaj komende
    join * v y
    /; 'alalalamakota'; 'ala';
    *; v; y;
    Polaczone drzewo:
    /; *; v; y; 'ala';
    lista zmiennych:
    v y
    Podaj komende
    vars
    lista zmiennych:
    v y
    Podaj komende
    comp 'xoxo' 'xala'
    Wyliczono: xaoxao moj panie!
    Podaj komende